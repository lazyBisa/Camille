// This file is automatically generated.
// Do not directly edit.
// http://www.mingweisamuel.com/riotapi-schema/tool/
// Version {{= spec.info.version }}
// Generated on {{= (new Date).toUTCString() }}
{{
    const dotUtils = require('./dotUtils.js');
}}

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using MingweiSamuel.Camille.Enums;


namespace MingweiSamuel.Camille.Endpoints
{
{{
    const endpointGroups = {};
    for (let path of Object.entries(spec.paths)) {
        let ep = path[1]['x-endpoint'];
        endpointGroups[ep] = endpointGroups[ep] || [];
        endpointGroups[ep].push(path);
    }
}}
{{/* Endpoint Classes */}}
{{
    for (let [ endpointName, endpointMethods ] of Object.entries(endpointGroups))
    {
        let endpoint = dotUtils.normalizeEndpointName(endpointName);
}}
    // {{= endpointName }}
    public class {{= endpoint }}Endpoints : EndpointBase
    {
        internal {{= endpoint }}Endpoints(RiotApi riotApi) : base(riotApi)
        {}

{{
        for (let [ route, path ] of endpointMethods)
        {
            let get = path.get;
            if (!get)
                continue;
            let operationId = get.operationId;
            let method = dotUtils.capitalize(operationId.slice(operationId.indexOf('.') + 1));

            let jsonInfo = get.responses['200'].content['application/json'];
            let returnType = dotUtils.stringifyType(jsonInfo.schema, endpoint);

            /* Cases if not rate limited. */
            let rateLimitExcluded = get['x-app-rate-limit-excluded'] ? true : false;

            /* Description processing. */
            let desc = get.description;
            let descArr = desc
                .replace(/(#+)\s*([^\\]+)\\n(.*?)([\\n$])/g,
                    (m, g1, g2, g3, g4) => `<h${g1.length}>${g2}</h${g1.length}>\\n${g3}${g4}`)
                .split('\n');

            /* Build argument comment & string. */
            let argBuilder = [];
            let makeParamCode = '';
            let allParams = get.parameters;
            if (allParams && allParams.length)
            {
                let pathParams = allParams.filter(p => 'path' === p.in)
                    .sort(p => route.indexOf(p.name));
                let reqParams = allParams.filter(p => 'path' !== p.in && p.required);
                let optParams = allParams.filter(p => 'path' !== p.in && !p.required)
                    .sort(p => {
                        let match = /(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+)/.exec(p.name);
                        return match.slice(1).reverse().join('');
                    });
                for (let paramList of [ pathParams, reqParams, optParams ])
                {
                    let required = paramList === pathParams;
                    for (let param of paramList)
                    {
                        argBuilder.push(', ',
                            dotUtils.stringifyType(param.schema, endpoint, !required),
                            ' ', param.name);
                        if (!required)
                            argBuilder.push(' = null');
                    }
                }
                makeParamCode = reqParams.concat(optParams)
                    .map(p => p.name)
                    .flatMap(n => [ `nameof(${n})`, n ])
                    .join(', ');
            }

            for (let asynch of [ '', 'Async' ])
            {
}}
        /// <summary>
{{
                for (var descLine of descArr)
                {
}}
        /// {{= descLine }}<br />
{{
                }
}}
        /// <br />
        /// <a href="{{= get.externalDocs.url }}">{{= get.externalDocs.description }}</a>
        /// </summary>
        /// <param name="region">Region to query.</param>
{{
                if (allParams)
                {
                    for (let param of allParams)
                    {
}}
        /// <param name="{{= param.name }}">{{= param.description || '' }} ({{= param.required ? 'required' : 'optional' }})</param>
{{
                    }
                }
}}
        /// <param name="cancellationToken">A cancellation token that can be used to cancel this task.</param>
        public {{= "Async" === asynch ? `Task<${returnType}>` : returnType }} {{= method }}{{= asynch }}(Region region{{= argBuilder.join('') }}, CancellationToken? cancellationToken = null)
        {
            return RiotApi.Get{{= asynch }}<{{= returnType }}>("{{= operationId }}", $"{{= route }}",
                region, MakeParams({{= makeParamCode }}), {{= rateLimitExcluded }}, cancellationToken);
        }

{{
            }
        }
}}
    }
{{
    }
}}
}